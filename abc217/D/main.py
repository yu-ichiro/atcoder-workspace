#!/usr/bin/env python3
# Generated by AtCoder Tools 2.8.0
# Copyright 2021 Yuichiro Smith
import sys
import itertools
from bisect import bisect_left

sys.setrecursionlimit(10**9)


def solve(L: int, Q: int, C: "List[int]", X: "List[int]"):
    queries = list(zip(C, X))
    cuts = []
    compress = (lambda x: bisect_left(cuts, x))

    for c, x in sorted(queries):
        if c == 2:
            break
        cuts.append(x)
    uf = [x-y for x, y in zip(itertools.chain([0], cuts), itertools.chain(cuts, [L]))]
    rank = [1] * len(uf)
    #
    # print(uf)

    def root(x):
        if uf[x] < 0:
            return x
        r = root(uf[x])
        uf[x] = r
        return r

    def size(x):
        return -uf[root(x)]

    def union(x, y):
        if x == y:
            return
        x, y = map(root, (x, y))
        rank_x, rank_y = map(lambda r: rank[r], (x, y))
        if rank_x < rank_y:
            x, y = y, x
        if rank_x == rank_y:
            rank[x] += 1
        uf[x] += uf[y]
        uf[y] = x
        rank[y] = 0
        # print(uf, rank)

    result = []
    for c, x in reversed(queries):
        x = compress(x)
        if c == 1:
            union(x, x+1)
        if c == 2:
            result.append(size(x))
        # print(uf)

    for res in reversed(result):
        print(res)
    return


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    L = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    C = [int()] * (Q)  # type: "List[int]"
    X = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        C[i] = int(next(tokens))
        X[i] = int(next(tokens))
    solve(L, Q, C, X)


if __name__ == '__main__':
    main()

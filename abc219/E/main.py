#!/usr/bin/env python3
# Generated by AtCoder Tools 2.8.0
# Copyright 2021 Yuichiro Smith
import sys
from collections import deque


def display_moat(moat: int):
    for y in range(4):
        for x in range(4):
            i = 1 << 4*y+x
            print("#" if i & moat else "_", end="")
        print()


def moat_connected(moat: int):
    test_moat = 0
    min_bound = 0
    max_bound = 3
    for y in range(4):
        for x in range(4):
            i = 1 << 4 * y + x
            if i & moat:
                # bfs
                queue = deque([(x, y)])
                while queue:
                    x, y = queue.popleft()
                    i = 1 << 4 * y + x
                    if not moat & i or test_moat & i:
                        continue
                    test_moat |= i
                    if min_bound <= x-1 <= max_bound:
                        queue.append((x-1, y))
                    if min_bound <= x+1 <= max_bound:
                        queue.append((x+1, y))
                    if min_bound <= y-1 <= max_bound:
                        queue.append((x, y-1))
                    if min_bound <= y+1 <= max_bound:
                        queue.append((x, y+1))
                return moat == test_moat
    return True


def moat_has_no_holes(moat: int):
    for y in range(1, 3):
        for x in range(1, 3):
            i = 1 << y * 4 + x
            if not moat & i:
                queue = deque([(x, y)])
                visited = 0
                while queue:
                    x, y = queue.popleft()
                    i = 1 << y * 4 + x
                    if moat & i or visited & i:
                        continue
                    visited |= i
                    if {0, 3}.intersection((x, y)):
                        break
                    queue.append((x-1, y))
                    queue.append((x+1, y))
                    queue.append((x, y-1))
                    queue.append((x, y+1))
                else:
                    return False
    return True


def valid_moat(moat: int):
    return moat_connected(moat) and moat_has_no_holes(moat)


def solve(A: "List[List[int]]"):
    village = 0
    for y, row in enumerate(A):
        for x, n in enumerate(row):
            village |= n << (y*4 + x)
    count = 0
    for moat in range(2**16):
        if village & moat != village:
            continue
        if not valid_moat(moat):
            continue
        # display_moat(moat)
        # input()
        count += 1
    print(count)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    A = [[int(next(tokens)) for _ in range(4)] for _ in range(4)]  # type: "List[List[int]]"
    solve(A)


if __name__ == '__main__':
    main()

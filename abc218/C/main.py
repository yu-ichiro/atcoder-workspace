#!/usr/bin/env python3
# Generated by AtCoder Tools 2.8.0
# Copyright 2021 Yuichiro Smith
import sys
from collections import deque

YES = "Yes"  # type: str
NO = "No"  # type: str

AIR = "."
BLOCK = "#"


class Shape:
    def __init__(self, N: int, shape_str: "List[str]"):
        self.orig = shape_str
        self.edge = N - 1
        self.shape1 = ""
        self.shape2 = ""
        self.shape3 = ""
        self.shape4 = ""
        self.shapes = set()
        self.normalize()

    def normalize(self):
        left = 0
        top = 0
        right = self.edge
        bottom = self.edge
        while True:
            if top > bottom or left > right:
                return
            if all(map(lambda s: s == AIR, self.orig[top])):
                top += 1
                continue
            if all(map(lambda line: line[left] == AIR, self.orig)):
                left += 1
                continue
            break
        while True:
            if all(map(lambda s: s == AIR, self.orig[bottom])):
                bottom -= 1
                continue
            if all(map(lambda line: line[right] == AIR, self.orig)):
                right -= 1
                continue
            break
        shape1 = "\n".join("".join(self.orig[y][x] for x in range(left, right+1, 1)) for y in range(top, bottom+1, 1))
        shape2 = "\n".join("".join(self.orig[y][x] for x in range(right, left-1, -1)) for y in range(bottom, top-1, -1))
        shape3 = "\n".join("".join(self.orig[y][x] for y in range(bottom, top-1, -1)) for x in range(left, right+1))
        shape4 = "\n".join("".join(self.orig[y][x] for y in range(top, bottom+1, 1)) for x in range(right, left-1, -1))
        self.shapes = {shape1, shape2, shape3, shape4}

    def __eq__(self, other):
        return bool(self.shapes & other.shapes)


def solve(N: int, S: "List[str]", T: "List[str]"):
    print(YES if Shape(N, S) == Shape(N, T) else NO)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    S = [next(tokens) for _ in range(N)]  # type: "List[str]"
    T = [next(tokens) for _ in range(N)]  # type: "List[str]"
    solve(N, S, T)


if __name__ == '__main__':
    main()

#!/usr/bin/env python3
# Generated by AtCoder Tools 2.8.0
# Copyright 2021 Yuichiro Smith
import sys
from collections import defaultdict, deque


def solve(N: int, M: int, S: "List[int]", T: "List[int]"):
    edges = {
        i: (s-1, t-1)
        for i, (s, t) in enumerate(zip(S, T))
    }
    graph = defaultdict(set)
    for i, (s, t) in edges.items():
        graph[s].add(i)

    path = [set()] + [None for _ in range(N-1)]
    maybe = [0] + [N for _ in range(N - 1)]
    distance = [-1 for _ in range(N)]
    queue = deque([0])
    while queue:
        n = queue.popleft()
        if distance[n] >= 0:
            continue
        distance[n] = maybe[n]
        # print(n, maybe, distance, queue)
        if n == N - 1:
            break
        for i in graph[n]:
            _, t = edges[i]
            if distance[t] >= 0:
                continue
            if maybe[t] > distance[n]:
                maybe[t] = distance[n] + 1
                queue.append(t)
                path[t] = path[n] | {i}
    shortest_len = distance[-1]
    if shortest_len < 0:
        for i in range(M):
            print(-1)
        return
    shortest_path = path[-1]
    for skip_i in range(M):
        if skip_i not in shortest_path:
            print(shortest_len)
            continue
        maybe = [0] + [N for _ in range(N-1)]
        distance = [-1 for _ in range(N)]
        queue = deque([0])
        while queue:
            n = queue.popleft()
            if distance[n] >= 0:
                continue
            distance[n] = maybe[n]
            # print(n, maybe, distance, queue)
            if n == N - 1:
                break
            for i in graph[n]:
                if skip_i == i:
                    continue
                _, t = edges[i]
                if distance[t] >= 0:
                    continue
                if maybe[t] > distance[n]:
                    maybe[t] = distance[n] + 1
                    queue.append(t)
        print(distance[-1])


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    s = [int()] * (M)  # type: "List[int]"
    t = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        s[i] = int(next(tokens))
        t[i] = int(next(tokens))
    solve(N, M, s, t)


if __name__ == '__main__':
    main()

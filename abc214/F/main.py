#!/usr/bin/env python3
import sys

MOD = 1000000007  # type: int
sys.setrecursionlimit(10**9)

def solve(S: str):
    N = len(S)
    # あるアルファベットsがi+1以降で最初に登場する位置を記録するテーブル
    nxt_pos = [[N] * 26 for _ in range(N+1)]
    for i in range(N-1,-1,-1):
        nxt_pos[i] = nxt_pos[i+1][:]
        if i + 1 >= N: continue
        # 1つ前（先）のアルファベットをこのタイミングで記録することで、1個前（先）の時点ではそのアルファベットが使われないようにする
        code = ord(S[i+1]) - ord("a")
        nxt_pos[i][code] = i+1
    # i=0の部分を上書きする
    nxt_pos[0][ord(S[0])-ord("a")] = 0
    # 先頭に空文字""があると考えてSを1-indexedとして扱う
    dp = [0 for _ in range(N+1)]
    dp[0] = 1
    for i in range(N):
        for s in range(26):
            # sに辿り着けなければスキップ
            if nxt_pos[i][s] >= N: continue
            # 次のsの1-indexedな位置を取得する
            nxt_s = nxt_pos[i][s] + 1
            # 自分自身からsに飛べる場合の数を飛んだ先に足し合わせる
            dp[nxt_s] += dp[i]
            dp[nxt_s] %= MOD
    # 空文字だけの部分文字列も数えてしまっているのでそれを除く
    dp[0] = 0
    return sum(dp) % MOD

# Generated by 2.6.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    S = next(tokens)  # type: str
    print(solve(S))
    

if __name__ == '__main__':
    main()
